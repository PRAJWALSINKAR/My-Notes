
Git Repo URL : https://github.com/ashokitschool/SBMS-39.git


IMP
----

Q) Revise All the codes that postman Gives
  like : 200 , 400,401

 
-------------------------------------
Why We Need Spring Web MVC —>
-----------------------------------
1) Build Web Applications Easily
➤ Helps you create web apps with URLs, forms, HTML pages, etc., using Java.

2) Follows MVC Design Pattern
➤ Clean separation of code:
Model → Data/Business logic
View → UI (JSP, Thymeleaf, etc.)
Controller → Request handling logic

3) Simplifies HTTP Handling
➤ Easily map URLs to Java methods using @Controller and @RequestMapping

======================================
Spring Web MVC( Model-View-Controller)
======================================

-> Spring Web MVC is one module in spring framework.

-> Using Spring Web MVC, we can develop below types of applications

		1) Web Application ( C 2 B )

		2) Distributed Application ( B 2 B )

-> We need to use 'springboot-starter-web' depenency to work with Spring Web MVC module.

-> 'web-starter' will provide embedded container by default. We no need to setup server manually.

				- Apache (Default)
				- Jetty
				- Netty 		

-> Spring Web MVC supports multiple presentation technologies

			Ex: JSP, Thymeleaf...

-> Spring Web MVC supports Form Binding. form data will be mapped to java object.

Note: When we develop java web app using servlets we need capture form data like below.

	 	String phno = request.getParameter("phno");
	 	Long ph = Long.parseLong(phno);

Note: We no need to write this logic in web mvc. It will take care of capturing form data and convert into corresponding data type and store into java object.
=========================
Some basic Info:-
--------------------------------------
 1. Tomcat (Default in Spring Boot):-
--------------------------------------
--> it is block server(means only one thread per user mean after completing one request then other request will start). 
-> Servlet-based:- Handles HTTP requests using the standard Java Servlet API.
-> Easy to use:- Comes pre-configured with Spring Boot (spring-boot-starter-web), no setup needed.
-> Supports JSP/Thymeleaf:- Great for traditional web applications with UI rendering.

-------------
 2. Jetty:-
-------------
-> Modular design: You can include only the parts you need — good for small or custom deployments.
-> Lightweight & fast startup : Slightly faster than Tomcat for small apps.
-> Servlet-compatible: Works similarly to Tomcat and supports JSP/Thymeleaf.

--------------
 3. Netty:-
--------------
->Non-blocking & event-driven: Handles many connections with fewer threads (high performance).
->Not Servlet-based: Uses its own I/O model, better for custom protocols or real-time apps (e.g., chat streaming).
->High concurrency support : Ideal for apps needing scalability under heavy load.
----------------------------------------------------------------------------------------	 
Tomcat: Classic web server → blocking → one thread per request → heavier.

Jetty: Lightweight web server → non-blocking/async → can handle many requests at once → easy to embed.

Netty: Not a web server → network framework → build your own fast, scalable server for any protocol.

---------------------------	
4 . JSP (JavaServer Pages)
--------------------------
-> Old but still used: Part of Java EE, used for creating dynamic HTML pages.
-> Java inside HTML: Allows you to embed Java code directly into HTML using special tags like <% ... %>.
-> Runs on servlet containers: Works well with Tomcat/Jetty, but not supported in newer embedded setups like Spring Boot + Netty.
-> Use when: You're working with traditional Java EE-style web apps or need compatibility with legacy code.

--------------
5. Thymeleaf
--------------
-> Modern & HTML5-based: A newer, template engine designed to work with natural HTML syntax.
-> No Java code in HTML: Uses readable tags like th:text, th:if to control logic.
-> Great integration with Spring Boot: Works smoothly for both server-side rendering and static templates.
-> Use when: You want clean, maintainable templates that work well with Spring Boot and modern browsers.
----------------
how I explain:-
-----------------
"JSP stands for JavaServer Pages. It’s an older presentation technology where we can embed Java code directly into HTML using special tags. It was widely used in traditional Java EE applications.
On the other hand, Thymeleaf is a modern server-side template engine designed for Spring. It allows us to write clean, readable HTML and inject dynamic data using simple attributes like th:text.
both’re used to build dynamic web pages by combining backend data with frontend HTML
I prefer Thymeleaf because it works naturally with Spring Boot, keeps templates close to real HTML, and improves readability and maintainability of the UI."

============================
Spring Web MVC Architecture
============================

=> In spring web mvc, below components will be involved...

1) DispatcherServlet : front controller/framework servlet

2) HandlerMapper : To identify request handler (controller)

3) Controller : Request Handler (spring bean) - we have to develop

4) ModelAndView : Model represents data & view represents UI page.

5) ViewResolver : To identify where view pages available in app

6) View : To render model data on view page.

=========================================
Building First Web App using Spring Boot
==========================================

1) Create Boot app with below dependencies

			a) web-starter :-Provides dependencies for building web applications in Spring Boot.
			b) thymeleaf-starter :- A modern server-side Java template engine for both web and standalone environments. Allows HTML to be correctly displayed in browsers and as static prototypes.

			c) devtools :-Provides fast application restarts, LiveReload, and configurations for enhanced development experience.

2) Create Controller class with required methods and map methods to HTTP methods with unique url patterns.

3) Create View Page (HTML + Thymeleaf) (under templates folder)		

4) Run the application and test it.	


----------------- Controller -------------------------------

@Controller
public class MsgController {

	@GetMapping("/greet")
	public ModelAndView getMsg2() {

		ModelAndView mav = new ModelAndView();
		mav.addObject("msg2", "Good Morning...!!");
		mav.setViewName("index");

		return mav;
	}

	@GetMapping("/welcome")
	public ModelAndView getMsg1() {

		ModelAndView mav = new ModelAndView();
		mav.addObject("msg1", "Welcome to Ashok IT");
		mav.setViewName("index");
		return mav;
	}
}

------------------------index.html------------------------------
<html>
	<body>
		<p th:text="${msg1}"></p>
		<p th:text="${msg2}"></p>
	</body>
</html>
----------------------------------------------------------------

----------------------------------------------------------------
ModelAndView combines model data & view name.

Used in Spring MVC controllers to return both at once.

Alternative: Use Model if returning only data.

----------------------------------------------------------------

===========================
Spring Web MVC Assignments
===========================

1) Develop Spring Boot web app to retrieve products data from db table and display in UI page as a table.


=========================
Form Based Applications
=========================

=> In every web app many forms will be available

		- login form
		- register form
		- search form

=> We need to capture form data and we need to perform operation on that data...


Note: Web MVC supports form binding.		

=============================================================
Develop Boot web app to save and retrieve products data 
==============================================================

1) Product.java (form binding + entity)

		Integer pid; (PK, Auto_Increment)
		String pname;
		Double price;
		Integer qty;

2) ProductRepo.java (JpaRepository)		

3) ProductService.java 

		- public boolean saveProduct(Product p);

		- public List<Product> getProducts();

4) ProductController.java

		public ModelAndView loadForm(); - GET

		public ModelAndView saveProduct(Product p) - POST	

		public ModelAndView getAllProducts()  - GET

5) View Pages
	
		index.html - form to enter data
		data.html  - table to display data

=================================
Embedded Database in spring boot
=================================

=> Embedded databases are called temporary databases

=> H2 we can use as embedded database

=> When application starts h2 db will start and when application stopped h2 db also gets stopped.

Note: If application re-started then we will loose old data.

=> H2 db is used only for practice purpose.

====================================
How to use H2 DB in spring boot ?
====================================

### Step-1 : Add h2 dependency in pom.xml file

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<scope>runtime</scope>
		</dependency>

### Step-2 : Configure H2 datasource properties in application.properties file


spring.datasource.username=ashokit
spring.datasource.password=abc
spring.datasource.url=jdbc:h2:mem:sbms

spring.jpa.show-sql=true

server.port=8081


### Step-3 : Run the application and access h2-console in browser

		URL : http://localhost:port/h2-console

	

============================================
How to change default container to  jetty ?
============================================

=> When we add web starter then tomcat will become default embedded container to run boot application.

=> If we want to change from tomcat to jetty then we need to make below changes in pom.xml

### Step-1 : Exclude tomact from web-starter dependency

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
			
		</dependency>

### Step-2 : Add jetty starter

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>

### Step-3 : Run the application and observe console.


==============
Requirement : 
==============

Develop  Spring Boot web application with below functionalities

	Registration Page : Name, Email, Pwd and Phno fields

	Login Page : Email & Pwd fields

	Dashboard Page : <msg>

Note: When user registered, application should send an email to the user.

Email Subject : Account Created - Ashok IT

Email Body : Congratuations.. you are onboard..


=================================
Email Sending using spring boot
=================================

=> To send emails using spring boot we have add 'mail-starter' dependency in pom.xml

=> We need to configure SMTP properties in application.properties file

Note: In SMTP props, we need to our gmail account credentials for authentication purpose.

Note: We need to generate "app password" for gmail for authentication.

	URL To generate app pwd: https://g.co/kgs/f1ic3P9

=> Spring boot provided JavaMailSender to send emails

		- SimpleMailMessage (plain text)

		- MimeMessage	(formats, attachments)

SimpleMailMessage
==================
Class: org.springframework.mail.SimpleMailMessage

Type: Plain text only.
HTML support: ❌ Cannot send HTML content.
Attachments: ❌ Cannot attach files.
Usage: Very simple emails like notifications.
--------------------------------------------------------------------------------
2️⃣ MimeMessage
=================

Class: jakarta.mail.internet.MimeMessage (wrapped by MimeMessageHelper)

Type: Rich content (HTML, inline images, attachments).
HTML support: ✅ Can send HTML formatted emails.
Attachments: ✅ Can attach files.
Usage: For advanced emails like newsletters, HTML templates.

InShort :-
SimpleMailMessage → Plain text, no attachments, simpler.
MimeMessage → HTML, attachments, more powerful.


============================================
Exception Handling in Boot web application	
============================================

=> Exception : Unexpected and unwanted situation

=> When exception occurs program will be terminated abnormally

=> We need to handle exceptions for app graceful termination.

=> We have below keywords to handle exceptions in java

		1) try
		2) catch
		3) throw
		4) throws
		5) finally	

=> Ways to Handle Exceptions in Spring MVC
  -----------------------------------------
--> Local try-catch inside controller (not good for big apps).
--> @ExceptionHandler inside the same controller (works only for that controller).
--> @ControllerAdvice + @ExceptionHandler → global handler for all controllers (best approach).

================================================================
@ControllerAdvice
public class AppExceptionHandler {

	@ExceptionHandler(value = Exception.class)
	public String handleAe(Exception e) {
		// logic
		return "exView";
	}
}
--------------------------------------------------------------------------
==> @ControllerAdvice
=======================
--> A global exception handler class.
--> Applies to all controllers in the project.
--> Helps to centralize error handling.
==================================================================

1.Controller-based vs Global exception handler in Spring

Q: When to use local (@ExceptionHandler) vs global (@ControllerAdvice) handler?

A:

Type		Use Case
Local 		(@ExceptionHandler in controller)	Exception specific to one controller
Global 		(@ControllerAdvice)			Exception handled across all controllers
Custom 		exception class	User-defined business logic errors

2. How controller exception handler works (MsgController)

Q: After throw in controller, how is @ExceptionHandler called?

A:

Exception occurs → normal execution stops.

Spring detects matching @ExceptionHandler in controller.

Executes handler method automatically.

Lines after the exception in original method do not execute.

3.. Two handlers in the same class: parent vs child

Q: If both Exception (parent) and ProductNotFoundException (child) handlers exist, which runs?

A: ✅ The most specific handler runs first (child).

Order in code does not matter.

4.. Two handlers for same exception in same class

Q: If two handlers for ProductNotFoundException exist in same class?

A: ❌ Ambiguous mapping → startup error

Spring cannot decide which to call.

Solution: merge logic or use different subclasses.

5. Local vs Global handler for same exception

Q: If controller has local handler and global @ControllerAdvice exists, which executes?

A: ✅ Local handler always executes first.

Global acts as fallback.

6. Changing priority between global and local

Q: Can global handler execute before local?

A: ✅ Yes, using @Order on @ControllerAdvice

Lower value → higher priority

Example: @ControllerAdvice @Order(1) → global executes before local handler.

----------------------------------------------------------------------------------------

1) What is web mvc ?
2) Advantages with Web MVC
3) Web MVC Architecture
4) What is Embedded Container
5) How to develop boot web app
6) How to send data from controller to UI
7) Web MVC Form with Form Binding
8) Embedded Database (h2)	
9) How to change default container
10) Email Sending using Spring Boot
11) Exception Handling in Web MVC
12) Login & Registration app
13) Product Store App (CRUD Ops)

===================================
Query Parameters (key-value)
===================================

=> Query Params are used to send data to server in URL

=> Query Params will represent data in key-value format

=> Query params will start with ?

=> Query Params will be seperated by &

=> Query Params will present at end of the URL

	ex: www.youtube.com/watch?v=ljsdf79/

		www.ashokit.in/course?name=sbms

		www.ashokit.in/course?cname=sbms&tname=ashok

Note: We can read query parameters from URL using @RequestParam annotation in the controller.		

================
Path Parameters
================

=> Path Params are used to send data to server in URL

=> Path Parameters will represent value directly As part of path

	ex : www.youtube.com/c/AshokIT

=> Path Parameters will be seperated by '/'

=> Path Parameters can present anywhere in the URL

	Ex :  www.ashokit.in/course/{java}/info

=> We can read Path Parameters using @PathVariable annotation.


=========================
What is @ResponseBody ?
=========================

=> It is used to send direct response to client without any view page.

=> This can be used at controller class level and method level.

Note: If we use at class level then it is applicable for all methods in that class.

		@Controller + @ResponseBody = @RestController


==================================================================

@Controller
public class MsgController {

	@GetMapping("/welcome")   //welcome?name=Prajwal
	@ResponseBody
	public String welcomeMethod(@RequestParam(value="name", required=false) String name) {
		return name + ", Welcome to Ashok IT";
	}

	@GetMapping("/greet/{name}") //greet/prajwal
	public String greetMethod(@PathVariable("name") String name, Model model) {
		model.addAttribute("msg", name+", Good Morning");
		return "index";
	}
}


=================
Form Validations
=================

=> To restrict users to provide valid information in the form

			- Client Side Validations

			- Server side validation

=> Client side validations will execute at browser. People can disable client side validations using inspect option in browser.	

=> Server side validations will execute in our code. These are highly recommended in application.

=> To implement server side validations we will use below starter in pom.xml file

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>


=> We can use below annotations to perform server side validations


@Valid → Tells Spring to apply validation rules on the object (e.g., @Valid User user).

@NotEmpty → Field must not be empty (""), but can be null.

@NotNull → Field must not be null, but can be empty ("").

@Size(min, max) → Field length must be between given range (e.g., password length).

@Email → Field must be a valid email format.

Note: We will use these annotations at binding class.


	@PostMapping("/user")
	public String handleSubmit(@Valid User user, BindingResult result, Model model) {

		if (result.hasErrors()) {
			// validation failed
			return "index";
		} else {
			// validation passed
			System.out.println(user);
			// logic to save in db
			model.addAttribute("msg", "User Saved");
			return "index";
		}
	}

========================================================================

Requirement : Develop spring boot web application to upload and download files.

=======================================================================

======================
Spring Boot with JSP
======================

=> JSP stands for Java Server Pages

=> JSP is used to develop presentation layer

Note: JSP will be translated to Servlet for execution..

=> Spring Web MVC supports JSP as presentation technology.

## Step-1 : Add tomcat-embed-jasper dependency in pom.xml file

		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>

## Step-2 : Create jsp pages in below location

		Location : src/main/webapp/pages/index.jsp

## Step-3 : Configure view resolver in application.properties file

		spring.mvc.view.prefix=/pages/
		spring.mvc.view.suffix=.jsp

=========================
Actuator in spring Boot
=========================

Spring Boot Actuator is a module that provides production-ready features like monitoring, health checks, and metrics for Spring Boot applications. We use it because, in real projects, once the application is deployed, we need to know whether it’s healthy, how it’s performing, and be able to troubleshoot issues without restarting. Actuator gives us endpoints like /actuator/health to check system health, /actuator/metrics for performance metrics, /actuator/loggers to change log levels at runtime, and integrations with tools like Prometheus and Grafana for observability. The main purpose is to help developers and operations teams monitor, manage, and maintain the application in production in a safe and standardized way.

->Actuator gives ready-made endpoints (like /health, /metrics) to check your app’s performance, health, and internals

=> Used to monitor and manage our spring boot applications

=> Production ready features...

=> With the help of actuators we can get below details

- Health of App
- Beans loaded
- Metrics
- Loggers
- URL Mappings
- Config Props
- Thread Dump
- Heap Dump

=> To work with actuators we need to add below dependency

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>

Note: With above dependency, By default /health will be exposed.

=> We need to write below property to expose other endpoints

	management.endpoints.web.exposure.include=*

=> We can exclude actuator endpoint like below

	management.endpoints.web.exposure.exclude=beans

=> This is command in browser to check :-    
         
@Controller
public class MsgController {

	@GetMapping("/welcome")   //welcome?name=Prajwal
	@ResponseBody
	public String welcomeMethod(@RequestParam(value="name", required=false) String name) {
		return name + ", Welcome to Ashok IT";
	}

	@GetMapping("/greet/{name}") //greet/prajwal
	public String greetMethod(@PathVariable("name") String name, Model model) {
		model.addAttribute("msg", name+", Good Morning");
		return "index";
	}
}

==============
Endpoint URLS
==============

/health : health of the app  (UP or DOWN)	

/beans : Spring Beans loaded

/configprops : Properties loaded

/mappings : URL patterns of our application

/threaddump : Threads info

/heapdump  : Heap info

/loggers : Logs of our applications

/shutdown : Stop server  (HTTP POST Request)

=============================
What is shutdown endpoint ?
=============================

=> It is used to stop the application.

Note: We need to enable shutdown endpiont in our properties file like below

		management.endpoint.shutdown.enabled=true

Note: Shutdown endpoint is mapped to POST request. We can send post request using POSTMAN software.
       => POST :- http://localhost:8080/actuator/shutdown
		


===================================
What are Profiles in Spring Boot ?
===================================

->Profiles help you load different settings based on where the app is running.
Like using one database in development and another in production.

=> Environment means a platform which is used to run our application.

=> In Real-time one application contains multiple environments like below

			- Local
			- Dev
			- QA
			- UAT
			- PILOT
			- PROD

-> Local env is used for development purpose

-> DEV env is used by developers for integration testing

-> QA env is used by Testing team for system integration testing

-> UAT(user acceptancy testing) env is used by Client side team for testing (GO/No-GO)

-> PILOT env is used to test app with live data (Pre-Prod)

-> PROD env is used for live access.


=> Below properties will be changing from environment to environment.

		- datasource properties
		- smtp properties
		- kafka properties
		- redis properties
		- payment-gateway properties



=> If we use single application.properties file to maintain config properties then maintanence will become difficult.

Note: to deploy code into env, everytime we have to change config props

=> To avoid this problem we will use Profiles in springboot

=> Using profiles we can maintain environment specific configuration.

			application.properties   ---- main file

			application-dev.properties

			application-qa.properties

			application-uat.properties

			application-prod.properties


=> We need to activate profile in main configuration file

			spring.profiles.active=dev			


========================================================================

1) Develop Java application to convert java object to json and json data to java object.

2) Develop Java application to convert java object to xml and xml data to java object.

========================================================================











