===============
lec 21 :-
================

=======================================
Spring Data JPA(Java Persistence API)
======================================
1) What is ORM & why
2) What is Data JPA & Why ?
3) Data JPA Repositories
		- CrudRepository
		- JpaRepository

4) What is Entity
5) Data JPA Application
6) Crud Operations
7) Pagination & Sorting
8) Query By Example (QBE)
9) findByXXX methods
10) Custom Queries (@Query)
11) Native SQL vs HQL
12) Primary Keys & Generators
13) Composite Primary Key
		- @Embeddable
		- @EmbeddedId
14) Timestamping
		- @CreationTimestamp
		- @UpdateTimestamp
15) Transactions
		- @Transactional
16) Connection Pooling
17) Association Mapping 
18) Conclusion

 Definition :->
--> JPA is a Java specification (not a tool or framework) that provides a standard way to map Java objects to database tables and perform database operations (CRUD) on them.


          +----------------------+
          |   Spring Boot App    |
          |  (@Entity classes,   |
          |   @Repository, etc) |
          +----------------------+
                     |
                     v
       +------------------------------+
       | spring-boot-starter-data-jpa |
       | - Provides JPA API           |
       | - Provides Spring Data Repo  |
       | - Integrates Hibernate (ORM) |
       +------------------------------+
                     |
                     v
          +------------------+
          |   Hibernate ORM  |
          | - Maps objects   |
          |   to tables      |
          | - Generates SQL  |
          +------------------+
                     |
                     v
          +------------------+
          | JDBC Driver      |
          | (mysql-connector-java) |
          | - Executes SQL   |
          |   in MySQL DB    |
          +------------------+
                     |
                     v
           +----------------+
           |   MySQL DB     |
           +----------------+
=============================
What is persistence layer ?
=============================

=> It contains set of classes & interfaces to communicate with database.

=> In java, we have several options to develop persistence layer

			1) JDBC
			2) Hibernate ORM
			3) Spring JDBC
			4) Spring ORM
			5) Spring Data JPA

Note: Spring Data JPA is the latest trend in the market to develope Persistence layer in java based applications.

===============================
Why to use Spring Data JPA     ----------> (Java Persistence API) ?
===============================

=> No need to write boilerplate code (duplicate)

*=> No need to write queries 

=> Ready made methods support is available

				- save () - insert record into db table
				- findById ()
				- findAll ()
				- count ()
				- deleteAll () 

=> Reducing development time

==============
What is ORM ?
==============

=> ORM stands for Object relational mapping

=> It is a technique to map java objects with database tables.

=> Using ORM we can deal with objects to perform DB operations.

=>*ORM is used to map Java objects to database tables, allowing developers to interact with databases using Java objects instead of SQL queries.

=> When we are using ORM framworks we need to map java classes with database tables.

			User.java     ============>  USER_TBL

			Product.java  ============>  PRODUCT_TBL

Note: The java class which is mapped with database table is called as Entity class.


			Entity class  ---------> db table
			Entity class variables -----> db tbl columns

			Entity class obj ------> db tbl row

==> // Without ORM
    String sql = "INSERT INTO USER_TBL (ID, NAME) VALUES (?, ?)";
    PreparedStatement ps = con.prepareStatement(sql);

==> // With ORM
   entityManager.save(user);

--> ORM will create USER table and map id â†’ column ID, name â†’ column NAME.


=> We will use below annotations to create Entity classes


@Entity : Represent java class as an Entity class

@Table : To map java class name with table name (Optional)

@Id  : Represents entity variable mapped with PK column in table

@Column	: To map java class variables with table column names 
			(optional)

==========================
What is Jpa Repository ?
==========================

=> Data JPA provided repository interfaces to simplify Persistence layer development.

			a) CrudRepository
			b) JpaRepository (more features)

Note: To perform DB operations we will create interface by extending from JpaRepository.


===========
Assignment
===========

Data JPA App with Oracle : https://www.youtube.com/watch?v=ZGKHCJsp4hg

=======
lec-23
=======
=======================================
Developing First Data JPA Application 
========================================

1) DB Setup (MysQL DB Server + MySQL Workbench)

 @@ Reference Video : youtube.com/watch?v=EsAIXPIsyQg

show databases;
create database sbms39;
use sbms39;
show tables;

2) Create Spring Boot application with below dependencies

		a) data-jpa-starter
		b) mysql-driver

3) Configure Datasource properties in application.properties

	spring.datasource.url=jdbc:mysql://localhost:3306/sbm39
 	spring.datasource.username=root
	spring.datasource.password=prajwal

	spring.jpa.hibernate.ddl-auto=update
	spring.jpa.show-sql=true


4) Create Entity class (class to table mapping)

5) Create Repository interface (CrudRepository/JpaRepository)

public interface EmpRepository extends CrudRepository<Employee, Integer>{

}

6) Create Service class and inject Repository interface

7) Test service class methods from start class.

		@@ save ( ) = insert + update ==> upsert
======
lec-24 
======

==============================
Crud Repository Methods (12)
==============================

=> CrudRepository is a spring data jpa repositry interface

=> CrudRepository providing methods to perform crud operation

@@ Note: To use crud repo methods we need to extend properties

1] save(T) : one object for Upsert

2] saveAll(Iterable T) : Collection of objects for upsert

3] findById(ID id) : To retrieve record based on given pk value

4] findAllById(Iterable ids) : Retrieve records based on given pks

5] findAll() : Retrieve all records from table

6] existsById(ID id) : To check record presence in table

7] count () : To get total no.of records

8] deleteById(ID id) : To delete record based on given pK

9] deleteAllById(Iterable ids) : Delete multiple records based on pks

10] delete(T entity) : Delete record based on given entity obj

11] deleteAll(Iterable entities) : delete records based on entities

12] deleteAll ( ) : To delete all records from table

======
GPT
======
Why Do We Need a Default Constructor in the Employee Entity?
example :-
		private Integer eid; // findById
		private String ename; // findByEname
		private Double esalary; // findByEsalary
		  
		  public Employee() {};   <<------
		 
       public Employee(Integer eid , String ename , Double esalary) {  
   		 this.eid = eid; // findById
   		 this.ename = ename; // findByEname
   		this.esalary = esalary;
	
        }

ANS:-(
==> Because Hibernate / JPA creates objects of your entity classes internally using reflection (not with new).

=> We need a default constructor because Hibernate uses it when retrieving data from the database â€” it creates empty objects and then fills them with column values.

==> Reflection requires a no-arg constructor so it can create a blank object first.

==> Later, Hibernate sets values into fields using setters (or directly using reflection).

Use of optional object and iterable objects :

===================
findByXXX methods	
===================

=> findBy methods are used to retrieve records based on non-primary key column values

Note : findBy methods are used for select operations only

	// select * from employee where ename=:ename
	public List<Employee> findByEname(String ename);
	
	// select * from employee where esalary=:esalary
	public List<Employee> findByEsalary(Double salary);

	//select * from employee where esalary >= :esalary
	public List<Employee> findByEsalaryGreaterThanEqual(Double salary);


==========
LEC-25
==========

================
Custom Queries	
================

=> Executing our own queries using data jpa.

=> To work with custom queries, we will use @Query annotation

=> Custom Queries we can write in 2 ways

			1) Native SQL (plain sql)
			2) HQL 

============
SQL Queries
============

=> SQL Queries are db dependent queries. 

=> In SQL query we will use table names and column names directly.

	Ex: select * from emp_tbl where emp_sal <= 10000.00

Note: If we want to change from one DB to another DB then we have to modify SQL queries and we have to re-test entire application.

=> To make our application loosely coupled with database we can use HQL queries.

============
HQL Queries
============

=> HQL stands for hibernate query language. 
=> HQL queries are database independent.
=> HQL queries will make our app loosely coupled with database.

=> In HQL queries we will use entity class name and entity variable names.

		Ex: From Employee where esal=1000.00

Note: Database can't understand HQL directley

=> HQL should be converted to SQL for execution.	

=> Dialect classes are used to convert HQL to SQL.

=> Every DB will have its own dialect class

		Ex: OracleDialect, MySQLDialect......		


SQL : select * from  emp_tbl
HQL : From Employee

SQL : select * from emp_tbl where emp_id=101
HQL : From Employee where eid=101 	

SQL : select emp_id, emp_name from emp_tbl	
HQL : select eid, ename from Employee

===================================================================

public interface EmpRepository extends CrudRepository<Employee , Integer> {

	@Query("from Employee")
	public List<Employee> getAllEmpsHQL();

	@Query("from Employee where eid=:id")
	public Employee getEmpById(Integer id);
	
	@Query(value = "select * from employee", nativeQuery = true)
	public List<Employee> getAllEmpsSQL();

	// select * from employee where ename=:ename
	public List<Employee> findByEname(String ename);

	// select * from employee where esalary=:esalary
	public List<Employee> findByEsalary(Double salary);

	// select * from employee where esalary >= :esalary
	public List<Employee> findByEsalaryGreaterThanEqual(Double salary);
}

==>
Use direct methods (like last 3) for common/simple queries.

Use @Query when:
You need custom queries (complex joins, multiple conditions).
Or you want to use native SQL instead of HQL.

-> Use direct (derived) methods for 70â€“80% of cases because they are short, clean, and auto-generated.
--> Use @Query (HQL/SQL) only when you need something custom or complex that canâ€™t be expressed easily in method names.
ex :-
@Query("select e from Employee e join e.department d where d.name = :dname")
List<Employee> getByDeptName(String dname);

Note:-
------
If the query is simple and follows naming conventions â†’ use derived methods âœ…
If the query is complex, involves joins, DB-specific things, or custom selects â†’ use @Query
==================================================================
==================================================================

=================================
Q) Which is better SQL or HQL ?
=================================

=> Performance wise SQL is better

=> Flexibility wise HQL is better

===============
JpaRepository
===============

=> This is predefined data jpa interface

=> It is providing several methods to perform DB ops

	JpaRepo = CrudRepo + Pagination + Sorting + QBE


=====================
What is Pagination ?
=====================

=> Divide total records into multiple pages for display.	

	- decide page size (how many records shud display)

	- calculage no.of pages required

Scenario-1 : 
	
		- Total records in db tbl : 50
		- page size : 10		
		- total pages = total-records/page-size	 => 5 pages

Scenario-2 : 
	
		- Total records in db tbl : 500
		- page size : 24		
		- total pages = total-records/page-size	 => 21 pages
---------
example
---------
public void getAllEmpsPagination() {

    int pageSize = 3;  // Fixed page size (Number of records per page)
    int pageNumber = 2; // Page number (Typically from UI)

    PageRequest pg = PageRequest.of(pageNumber - 1, pageSize);//this is method provided by jpa
    Page<Employee> page = empRepo.findAll(pg); // Fetch paginated records

    List<Employee> emps = page.getContent(); // Extract the list of employees from Page object

    emps.forEach(e -> System.out.println(e)); // Print each employee
}
===========================
 Page Object: Useful Methods
============================
getContent() â†’ List of current page records

getTotalPages() â†’ Total number of pages

getTotalElements() â†’ Total number of records

getNumber() â†’ Current page index

getSize() â†’ Page size (how many records per page)

hasNext(), hasPrevious() â†’ Navigation info

----------
Example
----------
public void getAllEmpsPagination() {
    int pageSize = 5;
    int pageNumber = 1; // from UI

    PageRequest pg = PageRequest.of(pageNumber - 1, pageSize);
    Page<Employee> page = empRepo.findAll(pg);

    List<Employee> emps = page.getContent();

    emps.forEach(System.out::println);

    System.out.println("Total Pages: " + page.getTotalPages());
    System.out.println("Total Records: " + page.getTotalElements());
    System.out.println("Current Page Number: " + (page.getNumber() + 1));
}



------
Method
------	                                  Type	                  Purpose
PageRequest.of(pageNumber - 1,pageSize)   Built-in (JPA)	Creates pagination object
empRepo.findAll(pg)	                  Built-in (JPA)       Retrieves paginated employees
page.getContent()	                  Built-in (JPA)       Extracts list of employees from Page object
emps.forEach(e -> System.out.println(e)   Built-in (Java)	Loops through and prints employees
getAllEmpsPagination()	                  User-defined	         Calls JPA methods to fetch paginated records



===================		
What is Sorting ?	
===================

=> Soring the records in ascending or descending order

Ex: display mobile based on price high to low

	display emps based on salary low to high	


===============
What is QBE ?	
===============

=> QBE means Query By Example

=> It is used to construct query dynamically

=> It is used to implement dynamic search functionalities



=====================
What is Timestamping
=====================

=> It is  used to populate record creation date and record updated date.

=> We will use below annotations in entity class to enable timestamping 

		@CreationTimestamp
		@UpdateTimestamp

----------------------------------------------------------

@Entity
public class Product {

	@Id
	private Integer pid;
	private String name;
	private Double price;
	
	@Column(updatable = false)
	@CreationTimestamp
	private LocalDate createdDate;
	
	@Column(insertable = false)
	@UpdateTimestamp
	private LocalDate updatedDate;

	//setters & getters

}

-----------------------------------

@Entity
@Table
@Id
@Column
@CreationTimestamp
@UpdateTimestamp

===============================
above annotation with an example :-
================================

Annotations Explanation
1. @Entity
This means the class is a database table.
Example: If you create a class Product, it will map to a product table in the database.

2. @Table
Defines the name of the table.
If you donâ€™t specify a name, Hibernate will use the class name as the table name.

3. @Id
Marks a field as the Primary Key of the table.
Every row in the table must have a unique value for this field.

4. @Column
Marks a field as a database column.
It can be used to specify properties like name, nullable, insertable, etc.

5. @CreationTimestamp
Automatically sets the field to the current timestamp when a record is inserted.
Example: When a new product is added, createdDate will store the current time.

6. @UpdateTimestamp
Automatically updates the field whenever the record is updated.
Example: When a product's price is changed, updatedDate will be set to the current time.

Simple Example :-

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import java.time.LocalDateTime;

@Entity  // This class is mapped to a table
@Table(name = "product") // Table name will be 'product'
public class Product {

    @Id  // Primary Key
    private Integer id;

    @Column  // Maps to a column in the table
    private String name;

    @Column
    private Double price;

    @CreationTimestamp  // Automatically set when inserting a new record
    private LocalDateTime createdDate;

    @UpdateTimestamp  // Automatically updated when the record is modified
    private LocalDateTime updatedDate;

    // Getters and Setters
}


How It Works in Real Life

When You Insert a New Product;


Product p = new Product();
p.setId(1);
p.setName("Laptop");
p.setPrice(1000.0);
productRepo.save(p);  // Saves to the database

ðŸ“Œ Database Table (product) After Insert

id	name	price	created_date	   updated_date
1	Laptop	1000.0	2025-02-26 10:00:00	
createdDate  are  set automatically.


When You Update the Product;

Product p = productRepo.findById(1).get();
p.setPrice(1200.0);
productRepo.save(p); // Updating product price

ðŸ“Œ Database Table After Update

id	name	price	created_date	updated_date
1	Laptop	1200.0	2025-02-26 10:00:00	2025-02-26 12:30:00

createdDate stays the same.
updatedDate is automatically updated.

Conclusion
-----------             -----------
Annotation	        What It Does
----------              -------------

@Entity 	     -  Marks class as a table
@Table(name="...")   -	Defines the table name
@Id	             -   Marks the Primary Key
@Column         -       Marks a field as a column
@CreationTimestamp  -   Auto-sets createdDate on insert
@UpdateTimestamp     -  Auto-updates updatedDate on update

==================================
ðŸ”¹ Composite Primary Key in JPA
==================================

A composite primary key is a primary key that consists of two or more columns. It uniquely identifies each record in a table by combining multiple fields.

ðŸ”¹ When to Use Composite Primary Key?
When a single column isn't sufficient to uniquely identify records.
When data naturally has multiple unique attributes (e.g., OrderID + ProductID in an OrderDetails table).
In many-to-many relationships, where a join table needs a composite key.

==> @EmbeddedId is used when your entityâ€™s primary key is made up of multiple columns (a composite key).
============
Generators :-
============

=> Generators are used to set the value for primary key columns

		@@ Primary Key = Not null + unique contrains

=> Primary key is used to maintain unique records in table

=> For every table atleast one primary key is required.

======================
Generator Strategies
======================

table : it will maintain seperate table for primary keys.

identity : it supports auto_increment (mysql)

sequence : it supports db sequences (oracle)

uuid (universal unique identifier) : alpha-numeric value for primary keys(pk) (datatype string)


	@Id
	@GeneratedValue(strategy = GenerationType.UUID)
	private String pid;

IDENTITY â†’ Use with MySQL/SQL Server â†’ good when you want DB to auto-increment IDs.

SEQUENCE â†’ Use with Oracle/Postgres â†’ good when you need fast, pre-fetched IDs.
     Values: 1, 2, 3, 4... (or whatever the sequence defines).
TABLE â†’ Use with any DB â†’ only when DB doesnâ€™t support identity/sequence (not common).

UUID â†’ Use with any DB â†’ good in distributed systems/microservices for globally unique IDs.


-------------------------
Why Use These Strategies?
-------------------------

- Avoid Manual Entry â€“ No need to manually set primary keys; they are auto-generated.
- Ensure Uniqueness â€“ Prevents duplicate primary keys in the database.
- Optimize Performance â€“ Some strategies (like SEQUENCE) improve insert speed.
- Database Portability â€“ Different strategies allow flexibility across databases.
- Scalability â€“ UUID allows unique IDs across multiple systems.

=========================
Composite Primary keys
==========================

=> If table is having more than one primary key then it is called as composite primary key


create table person(
	pid   int(10),
	name  varchar(100),
	email varchar(100),
	passport varchar(100),
	primary key(pid, passport)
)


================================================================

@@ Custom Generator : https://www.youtube.com/watch?v=IijGVtT9ZPk

-------------------------------------------------------------------
*Rollback Concept :-> @Transactional(rollbackOn = Exception.class)    open -18 project
----------------------------------------------------------------

ðŸ”¹ What Is @Transactional?
It is a Spring annotation that makes the entire method run as a single database transaction.

If anything fails inside the method (e.g. an exception occurs), Spring will roll back (undo) all the changes made to the database in this method.

ðŸ”¹ What Does rollbackOn = Exception.class Mean?
It tells Spring to roll back the transaction if any exception (checked or unchecked) occurs inside this method.

For example, if int i = 10/0; is uncommented (which causes a divide-by-zero error), both employee and address will not be saved.

ðŸ”¹ Why This Is Important:
This pattern ensures data consistency:

Avoids saving employee without address (or vice versa).

Prevents partial/dirty data in the database.

ðŸ”¹ Real-World Use Case:
When registering a new employee in an HR application:

You want both the Employee details and Address to be stored together.

If any step fails, nothing should be saved.

=========================
Database Relationships
=========================

=> We can see below relationship with db tables

1) One To One (Ex: Person with Passport)

Note: One record in parent table will have relationship with one record in child table.

	Ex: One person will have one passport.

==================
use of set in OTO
==================
set methods assign values to private fields.
p.setPassport(pp); makes Person aware of Passport.
pp.setPerson(p); makes Passport aware of Person.


2) One To Many (Ex: Employee with Address)

Note: One record in parent table will have relationship with multiple records in child table. 

	Ex: One Employee can have multiple addresses.

3) Many To One (Ex: Books with Author)

Note : Many records in one table will have relationship with one record.

	Ex: Multiple Books belongs to one Author

4) Many To Many (Ex : Users with Roles)

	Ex: Multiple Users will have multiple roles.

Note: To represent Many To Many relationship we need 3 tables.	

	Ex : users, roles, user_roles (join table)


=> When DB tables having relationships then we have to represent those relationships in Entity classes which is called as Association Mapping.	

=> To establish assocation mapping in entity classes we will use below annotations...

			- @OneToOne
			- @OneToMany
			- @ManyToOne
			- @ManyToMany
			- @JoinColumn
			- @JoinTable

==================
What is Cascade ?
==================

=> Parent table Operations should reflect on child table or not will be represented by CASCADE.

======================
What is Fetch Type ?
======================

=> Fetch Type represents child records should be loaded along with parent record or not

=> We have below 2 fetch types

			- Lazy (default)

			- Eager

=> Lazy means child records will be retrieved on demand basis.	

=> Eager means child records will be retrieved along with parent record in single query.

========================
One To One Relationship
========================

@Entity
@Table(name = "passport_tbl")
public class Passport {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer passportId;
	private String passportNum;
	private LocalDate issuedDate;
	private LocalDate expDate;

	@OneToOne
	@JoinColumn(name = "person_id")
	private Person person;


}

@Entity
@Table(name = "person_tbl")
public class Person {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer personId;

	private String name;

	private String gender;

	@OneToOne(mappedBy = "person", cascade = CascadeType.ALL)
	private Passport passport;

	}

=========================
One To Many Relationship
=========================		

@Entity
@Table(name = "emp_tbl")
public class Emp {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer eid;

	private String ename;

	private Double esal;

	@OneToMany(
			mappedBy = "emp", 
			cascade = CascadeType.ALL
	)


}

@Entity
@Table(name = "addr_tbl")
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer addrId;

	private String city;

	private String state;

	private String country;

	private String type;

	@ManyToOne
	@JoinColumn(name = "eid")
	private Emp emp;

}
	
==> When we retrieve the parent: default (LAZY) â†’ only parent data comes; 
                                EAGER â†’ parent + children come.

==> When we retrieve the child: default (EAGER) â†’ both child + parent come;
                              EAGER â†’ same behavior.

===========================
MANY TO MANY RELATIONSHIP
============================

table - 1 : users_tbl   (users will be stored)

table - 2 : roles_tbl   (roles will be stored)

table - 3 : user_roles  (users & roles mapping will be stored here)
------------------------------------------------------------------------------------
========================
Data JPA Specification
=======================

=> Data JPA Specification is used to build dynamic queries based on certain conditions.


@Entity
public class Product {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private String name;

	private Double price;

	private String category;

	// setters & getters
}

public class ProductSpecifications {
	
	public static Specification<Product> nameLike(String name) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.like(root.get("name"), "%" + name + "%");
    }

    public static Specification<Product> priceLessThan(double price) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.lessThan(root.get("price"), price);
    }

    public static Specification<Product> priceGreaterThan(double price) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.greaterThan(root.get("price"), price);
    }
}

public interface ProductRepo extends JpaRepository<Product, Long> {
	List<Product> findAll(Specification<Product> spec);
}


@Service
public class ProductService {

	@Autowired
	private ProductRepo productRepo;

	public List<Product> findProducts(String name, Double minPrice, Double maxPrice) {

		Specification<Product> spec = Specification.where(null);

		if (name != null) {
			spec = spec.and(ProductSpecifications.nameLike(name));
		}

		if (minPrice != null) {
			spec = spec.and(ProductSpecifications.priceGreaterThan(minPrice));
		}

		if (maxPrice != null) {
			spec = spec.and(ProductSpecifications.priceLessThan(maxPrice));
		}

		return productRepo.findAll(spec);
	}
}

============
Assignments
=============

1) Develop Data JPA application to insert person data into db table.

			person_id
			person_name
			person_gender
			person_dob
			person_photo
			person_resume

2) Develop data jpa application to call stored procedure

3) Develop data jpa application to retrieve only emp_name and emp_salary details from employee_tbl	using custom query.		

4) Insert employee records into table using custom generator..

	(Ex: AIT1, AIT2, AIT3......)

5) Develop data jpa application to retrieve emp data along with address using custom query.	

6) Write SQL queries to create  PERSON_TBL & PASSPORT_TBL with one to one relationship.

7) Write SQL queries to create EMPLOYEE_TBL & ADDRESS_TBL with One to Many Relationship.

8) Implement Many To Many Relationship Example

		Git Repo : https://github.com/ashokitschool/springboot_jpa_many_to_many_app.git


9) Develop Spring Boot application to export database table data into excel file.		

10) Develop Spring Boot application to export database table data into pdf file.

