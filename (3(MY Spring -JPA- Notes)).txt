===============
lec 21 :-
================

=======================================
Spring Data JPA(Java Persistence API)
======================================
1) What is ORM & why
2) What is Data JPA & Why ?
3) Data JPA Repositories
		- CrudRepository
		- JpaRepository

4) What is Entity
5) Data JPA Application
6) Crud Operations
7) Pagination & Sorting
8) Query By Example (QBE)
9) findByXXX methods
10) Custom Queries (@Query)
11) Native SQL vs HQL
12) Primary Keys & Generators
13) Composite Primary Key
		- @Embeddable
		- @EmbeddedId
14) Timestamping
		- @CreationTimestamp
		- @UpdateTimestamp
15) Transactions
		- @Transactional
16) Connection Pooling
17) Association Mapping 
18) Conclusion

 Definition :->
--> JPA is a Java specification (not a tool or framework) that provides a standard way to map Java objects to database tables and perform database operations (CRUD) on them.


          +----------------------+
          |   Spring Boot App    |
          |  (@Entity classes,   |
          |   @Repository, etc) |
          +----------------------+
                     |
                     v
       +------------------------------+
       | spring-boot-starter-data-jpa |
       | - Provides JPA API           |
       | - Provides Spring Data Repo  |
       | - Integrates Hibernate (ORM) |
       +------------------------------+
                     |
                     v
          +------------------+
          |   Hibernate ORM  |
          | - Maps objects   |
          |   to tables      |
          | - Generates SQL  |
          +------------------+
                     |
                     v
          +------------------+
          | JDBC Driver      |
          | (mysql-connector-java) |
          | - Executes SQL   |
          |   in MySQL DB    |
          +------------------+
                     |
                     v
           +----------------+
           |   MySQL DB     |
           +----------------+
=============================
What is persistence layer ?
=============================

=> It contains set of classes & interfaces to communicate with database.

=> In java, we have several options to develop persistence layer

			1) JDBC
			2) Hibernate ORM
			3) Spring JDBC
			4) Spring ORM
			5) Spring Data JPA

Note: Spring Data JPA is the latest trend in the market to develope Persistence layer in java based applications.

===============================
Why to use Spring Data JPA     ----------> (Java Persistence API) ?
===============================

=> No need to write boilerplate code (duplicate)

*=> No need to write queries 

=> Ready made methods support is available

				- save () - insert record into db table
				- findById ()
				- findAll ()
				- count ()
				- deleteAll () 

=> Reducing development time

==============
What is ORM ?
==============

=> ORM stands for Object relational mapping

=> It is a technique to map java objects with database tables.

=> Using ORM we can deal with objects to perform DB operations.

=>*ORM is used to map Java objects to database tables, allowing developers to interact with databases using Java objects instead of SQL queries.

=> When we are using ORM framworks we need to map java classes with database tables.

			User.java     ============>  USER_TBL

			Product.java  ============>  PRODUCT_TBL

Note: The java class which is mapped with database table is called as Entity class.


			Entity class  ---------> db table
			Entity class variables -----> db tbl columns

			Entity class obj ------> db tbl row

==> // Without ORM
    String sql = "INSERT INTO USER_TBL (ID, NAME) VALUES (?, ?)";
    PreparedStatement ps = con.prepareStatement(sql);

==> // With ORM
   entityManager.save(user);

--> ORM will create USER table and map id → column ID, name → column NAME.


=> We will use below annotations to create Entity classes


@Entity : Represent java class as an Entity class

@Table : To map java class name with table name (Optional)

@Id  : Represents entity variable mapped with PK column in table

@Column	: To map java class variables with table column names 
			(optional)

==========================
What is Jpa Repository ?
==========================

=> Data JPA provided repository interfaces to simplify Persistence layer development.

			a) CrudRepository
			b) JpaRepository (more features)

Note: To perform DB operations we will create interface by extending from JpaRepository.


===========
Assignment
===========

Data JPA App with Oracle : https://www.youtube.com/watch?v=ZGKHCJsp4hg

=======
lec-23
=======
=======================================
Developing First Data JPA Application 
========================================

1) DB Setup (MysQL DB Server + MySQL Workbench)

 @@ Reference Video : youtube.com/watch?v=EsAIXPIsyQg

show databases;
create database sbms39;
use sbms39;
show tables;

2) Create Spring Boot application with below dependencies

		a) data-jpa-starter
		b) mysql-driver

3) Configure Datasource properties in application.properties

	spring.datasource.url=jdbc:mysql://localhost:3306/sbm39
 	spring.datasource.username=root
	spring.datasource.password=prajwal

	spring.jpa.hibernate.ddl-auto=update
	spring.jpa.show-sql=true


4) Create Entity class (class to table mapping)

5) Create Repository interface (CrudRepository/JpaRepository)

public interface EmpRepository extends CrudRepository<Employee, Integer>{

}

6) Create Service class and inject Repository interface

7) Test service class methods from start class.

		@@ save ( ) = insert + update ==> upsert
======
lec-24 
======

==============================
Crud Repository Methods (12)
==============================

=> CrudRepository is a spring data jpa repositry interface

=> CrudRepository providing methods to perform crud operation

@@ Note: To use crud repo methods we need to extend properties

1] save(T) : one object for Upsert

2] saveAll(Iterable T) : Collection of objects for upsert

3] findById(ID id) : To retrieve record based on given pk value

4] findAllById(Iterable ids) : Retrieve records based on given pks

5] findAll() : Retrieve all records from table

6] existsById(ID id) : To check record presence in table

7] count () : To get total no.of records

8] deleteById(ID id) : To delete record based on given pK

9] deleteAllById(Iterable ids) : Delete multiple records based on pks

10] delete(T entity) : Delete record based on given entity obj

11] deleteAll(Iterable entities) : delete records based on entities

12] deleteAll ( ) : To delete all records from table

======
GPT
======
Why Do We Need a Default Constructor in the Employee Entity?
example :-
		private Integer eid; // findById
		private String ename; // findByEname
		private Double esalary; // findByEsalary
		  
		  public Employee() {};   <<------
		 
       public Employee(Integer eid , String ename , Double esalary) {  
   		 this.eid = eid; // findById
   		 this.ename = ename; // findByEname
   		this.esalary = esalary;
	
        }

ANS:-(
==> Because Hibernate / JPA creates objects of your entity classes internally using reflection (not with new).

=> We need a default constructor because Hibernate uses it when retrieving data from the database — it creates empty objects and then fills them with column values.

==> Reflection requires a no-arg constructor so it can create a blank object first.

==> Later, Hibernate sets values into fields using setters (or directly using reflection).

Use of optional object and iterable objects :

===================
findByXXX methods	
===================

=> findBy methods are used to retrieve records based on non-primary key column values

Note : findBy methods are used for select operations only

	// select * from employee where ename=:ename
	public List<Employee> findByEname(String ename);
	
	// select * from employee where esalary=:esalary
	public List<Employee> findByEsalary(Double salary);

	//select * from employee where esalary >= :esalary
	public List<Employee> findByEsalaryGreaterThanEqual(Double salary);


==========
LEC-25
==========

================
Custom Queries	
================

=> Executing our own queries using data jpa.

=> To work with custom queries, we will use @Query annotation

=> Custom Queries we can write in 2 ways

			1) Native SQL (plain sql)
			2) HQL 

============
SQL Queries
============

=> SQL Queries are db dependent queries. 

=> In SQL query we will use table names and column names directly.

	Ex: select * from emp_tbl where emp_sal <= 10000.00

Note: If we want to change from one DB to another DB then we have to modify SQL queries and we have to re-test entire application.

=> To make our application loosely coupled with database we can use HQL queries.

============
HQL Queries
============

=> HQL stands for hibernate query language. 
=> HQL queries are database independent.
=> HQL queries will make our app loosely coupled with database.

=> In HQL queries we will use entity class name and entity variable names.

		Ex: From Employee where esal=1000.00

Note: Database can't understand HQL directley

=> HQL should be converted to SQL for execution.	

=> Dialect classes are used to convert HQL to SQL.

=> Every DB will have its own dialect class

		Ex: OracleDialect, MySQLDialect......		


SQL : select * from  emp_tbl
HQL : From Employee

SQL : select * from emp_tbl where emp_id=101
HQL : From Employee where eid=101 	

SQL : select emp_id, emp_name from emp_tbl	
HQL : select eid, ename from Employee

===================================================================

public interface EmpRepository extends CrudRepository<Employee , Integer> {

	@Query("from Employee")
	public List<Employee> getAllEmpsHQL();

	@Query("from Employee where eid=:id")
	public Employee getEmpById(Integer id);
	
	@Query(value = "select * from employee", nativeQuery = true)
	public List<Employee> getAllEmpsSQL();

	// select * from employee where ename=:ename
	public List<Employee> findByEname(String ename);

	// select * from employee where esalary=:esalary
	public List<Employee> findByEsalary(Double salary);

	// select * from employee where esalary >= :esalary
	public List<Employee> findByEsalaryGreaterThanEqual(Double salary);
}

==>
Use direct methods (like last 3) for common/simple queries.

Use @Query when:
You need custom queries (complex joins, multiple conditions).
Or you want to use native SQL instead of HQL.

-> Use direct (derived) methods for 70–80% of cases because they are short, clean, and auto-generated.
--> Use @Query (HQL/SQL) only when you need something custom or complex that can’t be expressed easily in method names.
ex :-
@Query("select e from Employee e join e.department d where d.name = :dname")
List<Employee> getByDeptName(String dname);

Note:-
------
If the query is simple and follows naming conventions → use derived methods ✅
If the query is complex, involves joins, DB-specific things, or custom selects → use @Query
==================================================================
==================================================================

=================================
Q) Which is better SQL or HQL ?
=================================

=> Performance wise SQL is better

=> Flexibility wise HQL is better

===============
JpaRepository
===============

=> This is predefined data jpa interface

=> It is providing several methods to perform DB ops

	JpaRepo = CrudRepo + Pagination + Sorting + QBE


=====================
What is Pagination ?
=====================

=> Divide total records into multiple pages for display.	

	- decide page size (how many records shud display)

	- calculage no.of pages required

Scenario-1 : 
	
		- Total records in db tbl : 50
		- page size : 10		
		- total pages = total-records/page-size	 => 5 pages

Scenario-2 : 
	
		- Total records in db tbl : 500
		- page size : 24		
		- total pages = total-records/page-size	 => 21 pages
---------
example
---------
public void getAllEmpsPagination() {

    int pageSize = 3;  // Fixed page size (Number of records per page)
    int pageNumber = 2; // Page number (Typically from UI)

    PageRequest pg = PageRequest.of(pageNumber - 1, pageSize);//this is method provided by jpa
    Page<Employee> page = empRepo.findAll(pg); // Fetch paginated records

    List<Employee> emps = page.getContent(); // Extract the list of employees from Page object

    emps.forEach(e -> System.out.println(e)); // Print each employee
}
===========================
 Page Object: Useful Methods
============================
getContent() → List of current page records

getTotalPages() → Total number of pages

getTotalElements() → Total number of records

getNumber() → Current page index

getSize() → Page size (how many records per page)

hasNext(), hasPrevious() → Navigation info

----------
Example
----------
public void getAllEmpsPagination() {
    int pageSize = 5;
    int pageNumber = 1; // from UI

    PageRequest pg = PageRequest.of(pageNumber - 1, pageSize);
    Page<Employee> page = empRepo.findAll(pg);

    List<Employee> emps = page.getContent();

    emps.forEach(System.out::println);

    System.out.println("Total Pages: " + page.getTotalPages());
    System.out.println("Total Records: " + page.getTotalElements());
    System.out.println("Current Page Number: " + (page.getNumber() + 1));
}



------
Method
------	                                  Type	                  Purpose
PageRequest.of(pageNumber - 1,pageSize)   Built-in (JPA)	Creates pagination object
empRepo.findAll(pg)	                  Built-in (JPA)       Retrieves paginated employees
page.getContent()	                  Built-in (JPA)       Extracts list of employees from Page object
emps.forEach(e -> System.out.println(e)   Built-in (Java)	Loops through and prints employees
getAllEmpsPagination()	                  User-defined	         Calls JPA methods to fetch paginated records



===================		
What is Sorting ?	
===================

=> Soring the records in ascending or descending order

Ex: display mobile based on price high to low

	display emps based on salary low to high	


===============
What is QBE ?	
===============

=> QBE means Query By Example

=> It is used to construct query dynamically

=> It is used to implement dynamic search functionalities



=====================
What is Timestamping
=====================

=> It is  used to populate record creation date and record updated date.

=> We will use below annotations in entity class to enable timestamping 

		@CreationTimestamp
		@UpdateTimestamp

----------------------------------------------------------

@Entity
public class Product {

	@Id
	private Integer pid;
	private String name;
	private Double price;
	
	@Column(updatable = false)
	@CreationTimestamp
	private LocalDate createdDate;
	
	@Column(insertable = false)
	@UpdateTimestamp
	private LocalDate updatedDate;

	//setters & getters

}

-----------------------------------

@Entity
@Table
@Id
@Column
@CreationTimestamp
@UpdateTimestamp

===============================
above annotation with an example :-
================================

Annotations Explanation
1. @Entity
This means the class is a database table.
Example: If you create a class Product, it will map to a product table in the database.

2. @Table
Defines the name of the table.
If you don’t specify a name, Hibernate will use the class name as the table name.

3. @Id
Marks a field as the Primary Key of the table.
Every row in the table must have a unique value for this field.

4. @Column
Marks a field as a database column.
It can be used to specify properties like name, nullable, insertable, etc.

5. @CreationTimestamp
Automatically sets the field to the current timestamp when a record is inserted.
Example: When a new product is added, createdDate will store the current time.

6. @UpdateTimestamp
Automatically updates the field whenever the record is updated.
Example: When a product's price is changed, updatedDate will be set to the current time.

Simple Example :-

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import java.time.LocalDateTime;

@Entity  // This class is mapped to a table
@Table(name = "product") // Table name will be 'product'
public class Product {

    @Id  // Primary Key
    private Integer id;

    @Column  // Maps to a column in the table
    private String name;

    @Column
    private Double price;

    @CreationTimestamp  // Automatically set when inserting a new record
    private LocalDateTime createdDate;

    @UpdateTimestamp  // Automatically updated when the record is modified
    private LocalDateTime updatedDate;

    // Getters and Setters
}


How It Works in Real Life

When You Insert a New Product;


Product p = new Product();
p.setId(1);
p.setName("Laptop");
p.setPrice(1000.0);
productRepo.save(p);  // Saves to the database

📌 Database Table (product) After Insert

id	name	price	created_date	   updated_date
1	Laptop	1000.0	2025-02-26 10:00:00	
createdDate  are  set automatically.


When You Update the Product;

Product p = productRepo.findById(1).get();
p.setPrice(1200.0);
productRepo.save(p); // Updating product price

📌 Database Table After Update

id	name	price	created_date	updated_date
1	Laptop	1200.0	2025-02-26 10:00:00	2025-02-26 12:30:00

createdDate stays the same.
updatedDate is automatically updated.

Conclusion
-----------             -----------
Annotation	        What It Does
----------              -------------

@Entity 	     -  Marks class as a table
@Table(name="...")   -	Defines the table name
@Id	             -   Marks the Primary Key
@Column         -       Marks a field as a column
@CreationTimestamp  -   Auto-sets createdDate on insert
@UpdateTimestamp     -  Auto-updates updatedDate on update

==================================
🔹 Composite Primary Key in JPA
==================================

A composite primary key is a primary key that consists of two or more columns. It uniquely identifies each record in a table by combining multiple fields.

🔹 When to Use Composite Primary Key?
When a single column isn't sufficient to uniquely identify records.
When data naturally has multiple unique attributes (e.g., OrderID + ProductID in an OrderDetails table).
In many-to-many relationships, where a join table needs a composite key.

==> @EmbeddedId is used when your entity’s primary key is made up of multiple columns (a composite key).
============
Generators :-
============

=> Generators are used to set the value for primary key columns

		@@ Primary Key = Not null + unique contrains

=> Primary key is used to maintain unique records in table

=> For every table atleast one primary key is required.

======================
Generator Strategies
======================

table : it will maintain seperate table for primary keys.

identity : it supports auto_increment (mysql)

sequence : it supports db sequences (oracle)

uuid (universal unique identifier) : alpha-numeric value for primary keys(pk) (datatype string)


	@Id
	@GeneratedValue(strategy = GenerationType.UUID)
	private String pid;

IDENTITY → Use with MySQL/SQL Server → good when you want DB to auto-increment IDs.

SEQUENCE → Use with Oracle/Postgres → good when you need fast, pre-fetched IDs.
     Values: 1, 2, 3, 4... (or whatever the sequence defines).
TABLE → Use with any DB → only when DB doesn’t support identity/sequence (not common).

UUID → Use with any DB → good in distributed systems/microservices for globally unique IDs.


-------------------------
Why Use These Strategies?
-------------------------

- Avoid Manual Entry – No need to manually set primary keys; they are auto-generated.
- Ensure Uniqueness – Prevents duplicate primary keys in the database.
- Optimize Performance – Some strategies (like SEQUENCE) improve insert speed.
- Database Portability – Different strategies allow flexibility across databases.
- Scalability – UUID allows unique IDs across multiple systems.

=========================
Composite Primary keys
==========================

=> If table is having more than one primary key then it is called as composite primary key


create table person(
	pid   int(10),
	name  varchar(100),
	email varchar(100),
	passport varchar(100),
	primary key(pid, passport)
)


================================================================

@@ Custom Generator : https://www.youtube.com/watch?v=IijGVtT9ZPk

-------------------------------------------------------------------
*Rollback Concept :-> @Transactional(rollbackOn = Exception.class)    open -18 project
----------------------------------------------------------------

🔹 What Is @Transactional?
It is a Spring annotation that makes the entire method run as a single database transaction.

If anything fails inside the method (e.g. an exception occurs), Spring will roll back (undo) all the changes made to the database in this method.

🔹 What Does rollbackOn = Exception.class Mean?
It tells Spring to roll back the transaction if any exception (checked or unchecked) occurs inside this method.

For example, if int i = 10/0; is uncommented (which causes a divide-by-zero error), both employee and address will not be saved.

🔹 Why This Is Important:
This pattern ensures data consistency:

Avoids saving employee without address (or vice versa).

Prevents partial/dirty data in the database.

🔹 Real-World Use Case:
When registering a new employee in an HR application:

You want both the Employee details and Address to be stored together.

If any step fails, nothing should be saved.

=========================
Database Relationships
=========================

=> We can see below relationship with db tables

1) One To One (Ex: Person with Passport)

Note: One record in parent table will have relationship with one record in child table.

	Ex: One person will have one passport.

==================
use of set in OTO
==================
set methods assign values to private fields.
p.setPassport(pp); makes Person aware of Passport.
pp.setPerson(p); makes Passport aware of Person.


2) One To Many (Ex: Employee with Address)

Note: One record in parent table will have relationship with multiple records in child table. 

	Ex: One Employee can have multiple addresses.

3) Many To One (Ex: Books with Author)

Note : Many records in one table will have relationship with one record.

	Ex: Multiple Books belongs to one Author

4) Many To Many (Ex : Users with Roles)

	Ex: Multiple Users will have multiple roles.

Note: To represent Many To Many relationship we need 3 tables.	

	Ex : users, roles, user_roles (join table)


=> When DB tables having relationships then we have to represent those relationships in Entity classes which is called as Association Mapping.	

=> To establish assocation mapping in entity classes we will use below annotations...

			- @OneToOne
			- @OneToMany
			- @ManyToOne
			- @ManyToMany
			- @JoinColumn
			- @JoinTable

==================
What is Cascade ?
==================

=> Parent table Operations should reflect on child table or not will be represented by CASCADE.

======================
What is Fetch Type ?
======================

=> Fetch Type represents child records should be loaded along with parent record or not

=> We have below 2 fetch types

			- Lazy (default)

			- Eager

=> Lazy means child records will be retrieved on demand basis.	

=> Eager means child records will be retrieved along with parent record in single query.

========================
One To One Relationship
========================

@Entity
@Table(name = "passport_tbl")
public class Passport {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer passportId;
	private String passportNum;
	private LocalDate issuedDate;
	private LocalDate expDate;

	@OneToOne
	@JoinColumn(name = "person_id")
	private Person person;


}

@Entity
@Table(name = "person_tbl")
public class Person {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer personId;

	private String name;

	private String gender;

	@OneToOne(mappedBy = "person", cascade = CascadeType.ALL)
	private Passport passport;

	}

=========================
One To Many Relationship
=========================		

@Entity
@Table(name = "emp_tbl")
public class Emp {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer eid;

	private String ename;

	private Double esal;

	@OneToMany(
			mappedBy = "emp", 
			cascade = CascadeType.ALL
	)


}

@Entity
@Table(name = "addr_tbl")
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer addrId;

	private String city;

	private String state;

	private String country;

	private String type;

	@ManyToOne
	@JoinColumn(name = "eid")
	private Emp emp;

}
	
==> When we retrieve the parent: default (LAZY) → only parent data comes; 
                                EAGER → parent + children come.

==> When we retrieve the child: default (EAGER) → both child + parent come;
                              EAGER → same behavior.

===========================
MANY TO MANY RELATIONSHIP
============================

table - 1 : users_tbl   (users will be stored)

table - 2 : roles_tbl   (roles will be stored)

table - 3 : user_roles  (users & roles mapping will be stored here)
------------------------------------------------------------------------------------
========================
Data JPA Specification
=======================

=> Data JPA Specification is used to build dynamic queries based on certain conditions.


@Entity
public class Product {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private String name;

	private Double price;

	private String category;

	// setters & getters
}

public class ProductSpecifications {
	
	public static Specification<Product> nameLike(String name) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.like(root.get("name"), "%" + name + "%");
    }

    public static Specification<Product> priceLessThan(double price) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.lessThan(root.get("price"), price);
    }

    public static Specification<Product> priceGreaterThan(double price) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.greaterThan(root.get("price"), price);
    }
}

public interface ProductRepo extends JpaRepository<Product, Long> {
	List<Product> findAll(Specification<Product> spec);
}


@Service
public class ProductService {

	@Autowired
	private ProductRepo productRepo;

	public List<Product> findProducts(String name, Double minPrice, Double maxPrice) {

		Specification<Product> spec = Specification.where(null);

		if (name != null) {
			spec = spec.and(ProductSpecifications.nameLike(name));
		}

		if (minPrice != null) {
			spec = spec.and(ProductSpecifications.priceGreaterThan(minPrice));
		}

		if (maxPrice != null) {
			spec = spec.and(ProductSpecifications.priceLessThan(maxPrice));
		}

		return productRepo.findAll(spec);
	}
}

============
Assignments
=============

1) Develop Data JPA application to insert person data into db table.

			person_id
			person_name
			person_gender
			person_dob
			person_photo
			person_resume

2) Develop data jpa application to call stored procedure

3) Develop data jpa application to retrieve only emp_name and emp_salary details from employee_tbl	using custom query.		

4) Insert employee records into table using custom generator..

	(Ex: AIT1, AIT2, AIT3......)

5) Develop data jpa application to retrieve emp data along with address using custom query.	

6) Write SQL queries to create  PERSON_TBL & PASSPORT_TBL with one to one relationship.

7) Write SQL queries to create EMPLOYEE_TBL & ADDRESS_TBL with One to Many Relationship.

8) Implement Many To Many Relationship Example

		Git Repo : https://github.com/ashokitschool/springboot_jpa_many_to_many_app.git


9) Develop Spring Boot application to export database table data into excel file.		

10) Develop Spring Boot application to export database table data into pdf file.

